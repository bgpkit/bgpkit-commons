//! # Overview
//!
//! BGPKIT-Commons is a library for common BGP-related data and functions with a lazy-loading architecture.
//! Each module can be independently enabled via feature flags, allowing for minimal builds.
//!
//! ## Available Modules
//!
//! - [`asinfo`] - Autonomous System (AS) information, country lookup, and organization data (requires `asinfo` feature)
//! - [`as2rel`] - AS-level relationship data generated by BGPKIT (requires `as2rel` feature)
//! - [`bogons`] - IP prefix and ASN bogon detection from IANA registries (requires `bogons` feature)
//! - [`countries`] - Country code to name mappings from GeoNames (requires `countries` feature)
//! - [`mrt_collectors`] - RouteViews and RIPE RIS collector information (requires `mrt_collectors` feature)
//! - [`rpki`] - RPKI validation data from RIPE NCC and Cloudflare (requires `rpki` feature)
//!
//! ## Quick Start
//!
//! Add `bgpkit-commons` to your `Cargo.toml`:
//! ```toml
//! [dependencies]
//! bgpkit-commons = "0.8"
//! ```
//!
//! ### Basic Usage Pattern
//!
//! All modules follow the same lazy-loading pattern:
//! 1. Create a mutable `BgpkitCommons` instance
//! 2. Load the data you need by calling `load_xxx()` methods
//! 3. Access the data using the corresponding `xxx_yyy()` methods
//!
//! ```rust
//! use bgpkit_commons::BgpkitCommons;
//!
//! let mut commons = BgpkitCommons::new();
//!
//! // Load bogon data
//! commons.load_bogons().unwrap();
//!
//! // Use the data
//! if let Some(is_bogon) = commons.bogons_match("23456") {
//!     println!("ASN 23456 is a bogon: {}", is_bogon);
//! }
//! ```
//!
//! ### Working with Multiple Modules
//!
//! ```rust
//! use bgpkit_commons::BgpkitCommons;
//!
//! let mut commons = BgpkitCommons::new();
//!
//! // Load multiple data sources
//! commons.load_asinfo(false, false, false, false).unwrap();
//! commons.load_countries().unwrap();
//!
//! // Use the data together
//! if let Ok(Some(asinfo)) = commons.asinfo_get(13335) {
//!     println!("AS13335: {} ({})", asinfo.name, asinfo.country);
//! }
//! ```
//!
//! ## Feature Flags
//!
//! ### Module Features
//! - `asinfo` - AS information with organization and population data
//! - `as2rel` - AS relationship data
//! - `bogons` - Bogon prefix and ASN detection  
//! - `countries` - Country information lookup
//! - `mrt_collectors` - MRT collector metadata
//! - `rpki` - RPKI validation functionality
//!
//! ### Convenience Features  
//! - `all` (default) - Enables all modules for backwards compatibility
//!
//! ### Minimal Build Example
//! ```toml
//! [dependencies]
//! bgpkit-commons = { version = "0.8", default-features = false, features = ["bogons", "countries"] }
//! ```
//!
//! ## Error Handling
//!
//! Most access methods return `Result<T>` and will return an error if the corresponding module
//! hasn't been loaded yet. Some methods return `Option<T>` and will return `None` if not loaded.
//! Always call the appropriate `load_xxx()` method before accessing data.
//!
//! ## Data Persistence and Reloading
//!
//! All loaded data is kept in memory for fast access. Use the `reload()` method to refresh
//! all currently loaded data sources:
//!
//! ```rust
//! # use bgpkit_commons::BgpkitCommons;
//! let mut commons = BgpkitCommons::new();
//! commons.load_bogons().unwrap();
//!
//! // Later, reload all loaded data
//! commons.reload().unwrap();
//! ```

#![doc(
    html_logo_url = "https://raw.githubusercontent.com/bgpkit/assets/main/logos/icon-transparent.png",
    html_favicon_url = "https://raw.githubusercontent.com/bgpkit/assets/main/logos/favicon.ico"
)]

#[cfg(feature = "as2rel")]
pub mod as2rel;
#[cfg(feature = "asinfo")]
pub mod asinfo;
#[cfg(feature = "bogons")]
pub mod bogons;
#[cfg(feature = "countries")]
pub mod countries;
#[cfg(feature = "mrt_collectors")]
pub mod mrt_collectors;
#[cfg(feature = "rpki")]
pub mod rpki;

#[derive(Default)]
pub struct BgpkitCommons {
    #[cfg(feature = "countries")]
    countries: Option<crate::countries::Countries>,
    #[cfg(feature = "rpki")]
    rpki_trie: Option<crate::rpki::RpkiTrie>,
    #[cfg(feature = "mrt_collectors")]
    mrt_collectors: Option<Vec<crate::mrt_collectors::MrtCollector>>,
    #[cfg(feature = "mrt_collectors")]
    mrt_collector_peers: Option<Vec<crate::mrt_collectors::MrtCollectorPeer>>,
    #[cfg(feature = "bogons")]
    bogons: Option<crate::bogons::Bogons>,
    #[cfg(feature = "asinfo")]
    asinfo: Option<crate::asinfo::AsInfoUtils>,
    #[cfg(feature = "as2rel")]
    as2rel: Option<crate::as2rel::As2relBgpkit>,
}

impl BgpkitCommons {
    pub fn new() -> Self {
        Self::default()
    }

    /// Reload all data sources that are already loaded
    pub fn reload(&mut self) -> anyhow::Result<()> {
        #[cfg(feature = "countries")]
        if self.countries.is_some() {
            self.load_countries()?;
        }
        #[cfg(feature = "rpki")]
        if let Some(rpki) = self.rpki_trie.as_mut() {
            rpki.reload()?;
        }
        #[cfg(feature = "mrt_collectors")]
        if self.mrt_collectors.is_some() {
            self.load_mrt_collectors()?;
        }
        #[cfg(feature = "mrt_collectors")]
        if self.mrt_collector_peers.is_some() {
            self.load_mrt_collector_peers()?;
        }
        #[cfg(feature = "bogons")]
        if self.bogons.is_some() {
            self.load_bogons()?;
        }
        #[cfg(feature = "asinfo")]
        if let Some(asinfo) = self.asinfo.as_mut() {
            asinfo.reload()?;
        }
        #[cfg(feature = "as2rel")]
        if self.as2rel.is_some() {
            self.load_as2rel()?;
        }

        Ok(())
    }

    /// Load countries data
    #[cfg(feature = "countries")]
    pub fn load_countries(&mut self) -> anyhow::Result<()> {
        self.countries = Some(crate::countries::Countries::new()?);
        Ok(())
    }

    /// Load RPKI data
    #[cfg(feature = "rpki")]
    pub fn load_rpki(&mut self, date_opt: Option<chrono::NaiveDate>) -> anyhow::Result<()> {
        if let Some(date) = date_opt {
            self.rpki_trie = Some(crate::rpki::RpkiTrie::from_ripe_historical(date)?);
        } else {
            self.rpki_trie = Some(crate::rpki::RpkiTrie::from_cloudflare()?);
        }
        Ok(())
    }

    /// Load MRT mrt_collectors data
    #[cfg(feature = "mrt_collectors")]
    pub fn load_mrt_collectors(&mut self) -> anyhow::Result<()> {
        self.mrt_collectors = Some(crate::mrt_collectors::get_all_collectors()?);
        Ok(())
    }

    /// Load MRT mrt_collectors data
    #[cfg(feature = "mrt_collectors")]
    pub fn load_mrt_collector_peers(&mut self) -> anyhow::Result<()> {
        self.mrt_collector_peers = Some(crate::mrt_collectors::get_mrt_collector_peers()?);
        Ok(())
    }

    /// Load bogons data
    #[cfg(feature = "bogons")]
    pub fn load_bogons(&mut self) -> anyhow::Result<()> {
        self.bogons = Some(crate::bogons::Bogons::new()?);
        Ok(())
    }

    /// Load AS name and country data
    #[cfg(feature = "asinfo")]
    pub fn load_asinfo(
        &mut self,
        load_as2org: bool,
        load_population: bool,
        load_hegemony: bool,
        load_peeringdb: bool,
    ) -> anyhow::Result<()> {
        self.asinfo = Some(crate::asinfo::AsInfoUtils::new(
            load_as2org,
            load_population,
            load_hegemony,
            load_peeringdb,
        )?);
        Ok(())
    }

    #[cfg(feature = "asinfo")]
    pub fn load_asinfo_cached(&mut self) -> anyhow::Result<()> {
        self.asinfo = Some(crate::asinfo::AsInfoUtils::new_from_cached()?);
        Ok(())
    }

    /// Load AS-level relationship data
    #[cfg(feature = "as2rel")]
    pub fn load_as2rel(&mut self) -> anyhow::Result<()> {
        self.as2rel = Some(crate::as2rel::As2relBgpkit::new()?);
        Ok(())
    }
}
